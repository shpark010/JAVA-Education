import java.util.Scanner;

public class Solution {
	static int AnswerN;	// 먹을 수 있는 알의 수를 저장할 변수
	static int N = 10;	// 초기 바둑판 크기를 설정
	
	public static void main(String[] args) {
		   Scanner sc = new Scanner(System.in);
		   
		   int T = sc.nextInt(); // 테스트 케이스의 개수를 입력받는다.
		   
		   for(int test_case = 1 ; test_case <= T ; test_case++) { // 각 테스트 케이스마다 실행
			   N = sc.nextInt(); // 바둑판 크기를 입력받는다. 
		       char[][] board = new char[N][N]; // 입력된 바둑판의 상태를 저장할 2차원 배열을 생성한다.

		       // 입력된 바둑판의 상태를 2차원 배열에 저장한다.
		       for (int i = 0; i < N; i++) {
		           for (int j = 0; j < N; j++) {
		               board[i][j] = sc.next().charAt(0);
		           }
		       }

		       AnswerN = 0; // 먹을 수 있는 알의 수를 초기화한다.

		       // 모든 위치에 대해서 각각 먹을 수 있는 알의 수를 계산한다.
		       for (int i = 0; i < N; i++) {
		           for (int j = 0; j < N; j++) {
		               if (board[i][j] == 'X') { // 해당 위치가 포인 경우
		                   int cnt = check(board, i, j); // 해당 포가 먹을 수 있는 알의 수를 계산한다.
		                   if (cnt > AnswerN) AnswerN = cnt; // 먹을 수 있는 알의 수가 더 많은 경우, AnswerN을 업데이트한다.
		               }
		           }
		       }

		       // 각 테스트 케이스마다 번호와 먹을 수 있는 알의 수를 출력한다.
			   System.out.println("#" + test_case + ' ' + AnswerN);
		   }
		}

	// (i, j) 위치의 포가 먹을 수 있는 알의 수를 반환하는 메소드
	private static int countEat(char[][] board, int i, int j) {
	    // 만약 해당 칸에 포가 없으면 0 반환
	    if (board[i][j] != 'X') {
	        return 0;
	    }

	    // 먹을 수 있는 알의 수를 카운트하는 변수
	    int count = 0;

	    // 위쪽을 먹을 수 있는 알을 찾음
	    for (int r = i - 1; r >= 0; r--) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[r][j] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[r][j] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 아래쪽을 먹을 수 있는 알을 찾음
	    for (int r = i + 1; r < board.length; r++) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[r][j] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[r][j] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 왼쪽을 먹을 수 있는 알을 찾음
	    for (int c = j - 1; c >= 0; c--) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[i][c] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[i][c] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 오른쪽을 먹을 수 있는 알을 찾음
	    for (int c = j + 1; c < board.length; c++) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[i][c] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[i][c] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 먹을 수 있는 알의 수 반환
	    return count;
	}
}