import java.util.Scanner;

public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);

		int T = sc.nextInt(); // 테스트 케이스의 개수

		for (int tc = 1; tc <= T; tc++) {
			int N = sc.nextInt(); // 바둑판의 크기

			char[][] board = new char[N][N]; // 바둑판

			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					board[i][j] = sc.next().charAt(0); // 바둑판 입력 받기
				}
			}

			int count = 0; // 먹을 수 있는 알의 수

			// 포의 위치를 찾는다
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < N; j++) {
					if (board[i][j] == 'X') {
						// 포가 먹을 수 있는 알의 수를 센다
						count += countEat(board, i, j);
					}
				}
			}

			// 결과 출력
			System.out.println("#" + tc + " " + count);
		}

		sc.close();
	}

	// (i, j) 위치의 포가 먹을 수 있는 알의 수를 반환하는 메소드
	private static int countEat(char[][] board, int i, int j) {
	    // 만약 해당 칸에 포가 없으면 0 반환
	    if (board[i][j] != 'X') {
	        return 0;
	    }

	    // 먹을 수 있는 알의 수를 카운트하는 변수
	    int count = 0;

	    // 위쪽을 먹을 수 있는 알을 찾음
	    for (int r = i - 1; r >= 0; r--) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[r][j] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[r][j] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 아래쪽을 먹을 수 있는 알을 찾음
	    for (int r = i + 1; r < board.length; r++) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[r][j] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[r][j] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 왼쪽을 먹을 수 있는 알을 찾음
	    for (int c = j - 1; c >= 0; c--) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[i][c] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[i][c] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 오른쪽을 먹을 수 있는 알을 찾음
	    for (int c = j + 1; c < board.length; c++) {
	        // 만약 해당 칸에 알이 있으면
	        if (board[i][c] != 'L') {
	            // 만약 그 알이 포라면 먹을 수 없음
	            if (board[i][c] == 'X') {
	                break;
	            } else {
	                // 그 알이 일반 알이면 먹을 수 있음
	                count++;
	                break;
	            }
	        }
	    }

	    // 먹을 수 있는 알의 수 반환
	    return count;
	}
}